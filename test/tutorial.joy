(*
This tutorial is taken from 42minjoy.

It uses a minimal set of 26 builtins:

input: get
output: put, putch
stack: dup, swap, pop
list: cons, uncons, i
conditional: index
relational: <, =, >
arithmetic: *, +, -, /
logical: and, or, not
Joy stack: stack, unstack
Joy symbols: body, sametype
Joy syntax: stop, setautoput

Comments on some of the builtins:

"putch" is needed, because in a typeless stack there is no other way to output
a character.
">" has been defined as "swap <" but that is not entirely correct. It seems
better to have this added as a builtin.
"sametype" cannot be used in a typeless stack and is only needed in the
joy-in-joy interpreter.
"body" likewise is not available in a compiled environment, but is used in the
joy-in-joy interpreter.
"stop" implements the automatic output of the top of the stack after the
program finishes.
"setautoput" controls the automatic output. It is needed in a typeless stack,
because the runtime cannot always correctly guess the type of the stack item
to be printed and in that case it should be possible to turn the automatic
output off.
The builtin "nothing" has been made obsolete. It is not needed to implement
"null", that can be implemented as "0 =", and it is not necessary to allow
"uncons" on an empty list.
Builtin "select" has not even been mentioned. It is only used in the joy-in-joy
interpreter and seems to have no other purpose.
*)
LIBRA
put_bool == [ [ "true" ] [ "false" ] ] index i put ;
nl == 10 putch ;
# > == swap < ;
reverse == [ ] swap shunt ;
step1 == [ dup ] dip1 swap [ ] = [ [ step2 ] [ pop pop ] ] index i ;
step2 == [ uncons ] dip1 dup [ swap ] dip1 [ i ] first1 rollup1 [ step1 ]
	 cons cons cons cons [ [ ] cons [ first1 ] first1 ] dip1 cons i ;
shunt == [ cnos ] step1 ;
cnos == swap cons ;
concat1 == [ reverse ] c shunt ;
dip1 == swap [ i ] first1 swap [ ] cons [ first1 ] cons cons cons i ;
c == [ swap ] dip1 i ;
last == dup rest1 null1 [ first1 ] [ rest1 last ] branch1 ;
# null1 == car nothing sametype ;
null1 == 0 = ;
car == uncons pop ;
first1 == uncons pop ;
rest1 == uncons swap pop ;
branch1 == swap pair index i ;
pair == [ ] cons cons ;
member == swap contains ;
contains == false swap [ = or ] cons fold1 ;
fold1 == [ swap ] dip1 step1 ;
sum == 0 [ + ] fold1 ;
space == 32 ;
product == 1 [ * ] fold1 ;
put_list_chr == 91 putch space putch uncons swap putch [ space putch putch ] step1 space putch 93 putch ;
length == 0 [ pop 1 + ] fold1 ;
putnl == put nl ;
twice == dup b ;
b == [ i ] dip1 i ;
thrice == dup [ twice ] dip1 i ;
square == dup * ;
pred1 == 1 - ;
times1 == dup 0 = [ pop pop ] [ [ dup [ i ] dip1 ] dip1 pred1 times1 ] branch1 ;
map1 == maprev reverse ;
maprev == [ ] rollup1 shuntmap ;
rollup1 == swap [ swap ] dip1 ;
shuntmap == [ [ cnos ] b ] cons step1 ;
unit == [ ] cons ;
construct2 == [ [ nullary1 ] cons dip1 swap ] map1 ;
nullary1 == stack swap dip1 rest1 cons unstack ;
unpair == uncons uncons pop ;
definition == first body ;
cdr == uncons swap pop ;
x1 == dup i ;
y == fix i ;
fix == [ duco ] first1 swap cons duco ;
duco == dup cons ;
# <= == succ < ;
# succ == 1 + ;
factorial_rec == dup 2 < [ pop 1 ] [ dup pred1 factorial_rec * ] branch1 ;
rolldown1 == [ swap ] dip1 swap ;
small1 == uncons null1 swap pop ;
quicksort == dup small1 [ ] [ partition quicksort [ quicksort ] dip1 concat1 ] branch1 ;
partition == [ [ ] [ ] ] dip1 dup [ first1 > [ cnos ] [ swap [ cnos ] dip1 ] branch1 ] cons [ dup ] first1 cnos step1 ;
quicksort1 == dup small1 [ ] [ partition1 quicksort1 [ quicksort1 ] dip1 concat1 ] branch1 ;
partition1 == [ [ ] [ ] ] dip1 dup first1 [ first1 > [ cnos ] [ swap [ cnos ] dip1 ] branch1 ] cons [ first1 ] first1 cnos [ dup ] first1 cnos step1 ;
END
111 222 + .
1 2 + 3 4 + * .
2 2 + 2 2 * = put_bool nl .
6 6 * 5 7 * > put_bool nl .
true false or true and not put_bool nl .
[ 1 2 3 4 5 ] reverse .
[ peter paul ] [ mary jane ] concat1 .
[ 11 false 'X 44 ] last .
3 [ 1 5 3 4 2 ] member put_bool nl .
3 [ 1 5 6 4 2 ] member put_bool nl .
[ 1 2 3 4 ] dup sum put product .
111 [ 222 333 ] cons .
[ 11 22 33 44 55 ] uncons uncons put put .
0 setautoput .
[ 'a 'b ] [ 'd 'e 'f ] concat1 dup put_list_chr nl .
uncons uncons 'c swap cons cons cons dup put_list_chr nl .
dup length putnl .
reverse length putnl .
1 setautoput .
# get get + .
# 123 456
111 222 [ + put ] i nl .
111 [ put + ] reverse 222 swap i nl .
3 7 100 [ * ] dip1 + .
[ 1 2 3 ] [ dup * put ] step1 nl .
2 [ dup * ] i .
2 [ dup * ] twice .
2 [ dup * ] thrice .
2 [ square ] 0 times1 .
2 [ square ] 1 times1 .
2 [ square ] 2 times1 .
2 [ square ] 3 times1 .
2 [ square ] 4 times1 .
2 [ square ] 5 times1 .
[ 7 ] 10 times1 stack .
[ 1 2 3 ] [ dup * ] map .
[ 1 2 3 ] 0 [ dup * + ] fold1 .
11 12 [ [ + ] [ * ] [ pop unit ] [ dup pair ] ] construct2 .
[ [ pair [ square ] map1 unpair + ] [ pop ] [ ] ] construct2 .
[ ] unstack 11111 .
64 .
64 .
255 .
65 putch nl .
97 putch nl .
'g putch nl .
[ Smith Jones Robinson ] last .
[ last ] definition .
[ Smith Jones Robinson ] [ last ] definition i .
[ Smith Jones Robinson ]
[ swap dup rest1 null1 [ car swap pop ] [ cdr swap x1 ] branch1 ] x1 .
[ Smith Jones Robinson ]
[ swap dup rest1 null1 [ car swap pop ] [ cdr swap i ] branch1 ] y .
6 factorial_rec .
6 [ swap dup 1 <= [ pop pop 1 ] [ dup pred1 rolldown1 x1 * ] branch1 ]
x1 .
6 [ swap dup 1 <= [ pop pop 1 ] [ dup pred1 rolldown1 i * ] branch1 ]
y .
[ 1 9 2 8 3 7 4 6 5 ] quicksort .
[ 5 6 4 7 3 8 2 9 1 ] quicksort .
[ 1 2 3 4 5 6 7 8 9 ] quicksort .
[ 9 8 7 6 5 4 3 2 1 ] quicksort .
[ quicksort ] definition .
[ [ 1 Smith ] [ 3 Jones ] [ 2 Robinson ] [ 4 Brown ] ] quicksort1 .
0 setautoput .
[ ] [ NURKS Peter 1989 year 3 major Computer Science ] cnos
    [ ABELSON Mary 1990 year 2 major Logic ] cnos
    [ ZEEMAN Fred 1988 year 2 major Accounting ] cnos
    [ MORRIS Janna 1992 year 1 major undecided ] cnos
quicksort1 [ putnl ] step1 .
