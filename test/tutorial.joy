(*
This tutorial is taken from 42minjoy.

It uses a minimal set of 27 builtins:

input: get
output: put, putch
stack: dup, swap, pop
list: null, cons, uncons, i
conditional: index
relational: <, =, >
arithmetic: *, +, -, /
logical: and, or, not
Joy stack: stack, unstack
Joy symbols: body, sametype
Joy syntax: stop, setautoput

Comments on some of the builtins:

"putch" is needed, because in a typeless stack there is no other way to output
a character.
">" has been defined as "swap <" but that is not entirely correct. It seems
better to have this added as a builtin.
"sametype" cannot be used in a typeless stack and is only needed in the
joy-in-joy interpreter.
"body" likewise is not available in a compiled environment, but is used in the
joy-in-joy interpreter.
"stop" implements the automatic output of the top of the stack after the
program finishes.
"setautoput" controls the automatic output. It is needed in a typeless stack,
because the runtime cannot always correctly guess the type of the stack item
to be printed and in that case it should be possible to turn the automatic
output off.
The builtin "nothing" has been made obsolete. It is not needed to implement
"null", that can be implemented as "0 =", and it is not necessary to allow
"uncons" on an empty list.
Builtin "select" has not even been mentioned. It is only used in the joy-in-joy
interpreter and seems to have no other purpose.
*)
LIBRA
# put_bool == [ [ "true" ] [ "false" ] ] index i put ;
nl == 10 putch ;
reverse == [ ] swap shunt ;
step == [ dup ] dip swap [ ] = [ [ step2 ] [ pop pop ] ] index i ;
step2 == [ uncons ] dip dup [ swap ] dip [ i ] first rollup [ step ]
	 cons cons cons cons [ [ ] cons [ first ] first ] dip cons i ;
shunt == [ cnos ] step ;
cnos == swap cons ;
concat == [ reverse ] c shunt ;
dip == swap [ i ] first swap [ ] cons [ first ] cons cons cons i ;
c == [ swap ] dip i ;
last == dup rest null [ first ] [ rest last ] branch ;
# null == 0 = ;
car == uncons pop ;
first == uncons pop ;
rest == uncons swap pop ;
branch == swap pair index i ;
pair == [ ] cons cons ;
member == swap contains ;
contains == false swap [ = or ] cons fold ;
fold == [ swap ] dip step ;
sum == 0 [ + ] fold ;
space == 32 ;
product == 1 [ * ] fold ;
put_list_chr == 91 putch space putch uncons swap putch [ space putch putch ]
		step space putch 93 putch ;
length == 0 [ pop 1 + ] fold ;
putnl == put nl ;
twice == dup b ;
b == [ i ] dip i ;
thrice == dup [ twice ] dip i ;
square == dup * ;
pred == 1 - ;
times == dup 0 = [ pop pop ] [ [ dup [ i ] dip ] dip pred times ] branch ;
map == maprev reverse ;
maprev == [ ] rollup shuntmap ;
rollup == swap [ swap ] dip ;
shuntmap == [ [ cnos ] b ] cons step ;
unit == [ ] cons ;
construct2 == [ [ nullary ] cons dip swap ] map ;
nullary == stack swap dip rest cons unstack ;
unpair == uncons uncons pop ;
definition == first body ;
cdr == uncons swap pop ;
x == dup i ;
y == fix i ;
fix == [ duco ] first swap cons duco ;
duco == dup cons ;
factorial_rec == dup 2 < [ pop 1 ] [ dup pred factorial_rec * ] branch ;
rolldown == [ swap ] dip swap ;
small == dup null [ [ uncons null ] [ true ] ] index i swap pop ;
quicksort == dup small [ ] [ partition quicksort [ quicksort ] dip concat ]
	     branch ;
partition == [ [ ] [ ] ] dip dup [ first > [ cnos ] [ swap [ cnos ] dip ]
	     branch ] cons [ dup ] first cnos step ;
quicksort1 == dup small [ ] [ partition1 quicksort1 [ quicksort1 ] dip concat ]
	      branch ;
partition1 == [ [ ] [ ] ] dip dup first [ first > [ cnos ] [ swap [ cnos ] dip
	      ] branch ] cons [ first ] first cnos [ dup ] first cnos step ;
quicksort2 == dup small [ ] [ partition2 quicksort2 [ quicksort2 ] dip concat ]
	      branch ;
partition2 == [ [ ] [ ] ] dip dup first [ first gt [ cnos ] [ swap [ cnos ] dip
	      ] branch ] cons [ first ] first cnos [ dup ] first cnos step ;
put_list_int == "[ " putchars [ put_int ] step "]" putchars ;
put_list_str == "[ " putchars [ put_str ] step "]" putchars ;
put_list_sym == "[ " putchars [ putchars space putch ] step "]" putchars ;
ps == "stack: " putchars stack putnl ;
unswonsd == [ unswons ] dip ;
popd == [ pop ] dip ;
put_rec_aux == "[ " putchars
[ dup null_str not ]
[ unswonsd uncons_str
  [
    [ [ 's putchars space putch ]
      [ 'i put_int ]
      [ ]
    ] case
  ] dip
  [ over '( = ]
  [ swap pop put_rec_aux ]
  [ uncons_str
    [ over ') = ]
    [ swap pop popd "] " putchars ]
    [ cons_str ] ifte
  ] ifte
] while ;
put_rec == put_rec_aux "] " putchars pop pop ;
END

0 setautoput .
111 222 + put_int nl .
1 2 + 3 4 + * put_int nl .
2 2 + 2 2 * = put_bool nl .
6 6 * 5 7 * > put_bool nl .
true false or true and not put_bool nl .
[ 1 2 3 4 5 ] reverse put_list_int nl .
[ peter paul ] [ mary jane ] concat put_list_sym nl .
[ 11 false 'X 44 ] last put_int nl .
3 [ 1 5 3 4 2 ] member put_bool nl .
3 [ 1 5 6 4 2 ] member put_bool nl .
[ 1 2 3 4 ] dup sum put product put_int nl .
111 [ 222 333 ] cons put_list_int nl .
[ 11 22 33 44 55 ] uncons uncons put_list_int space putch put_int put_int nl .
[ 'a 'b ] [ 'd 'e 'f ] concat dup put_list_chr nl .
uncons uncons 'c swap cons cons cons dup put_list_chr nl .
dup length put_int nl .
reverse length put_int nl .
# get get + .
# 123 456
111 222 [ + put_int ] i nl .
111 [ put_int + ] reverse 222 swap i nl .
3 7 100 [ * ] dip + put_int nl .
[ 1 2 3 ] [ dup * put_int ] step nl .
2 [ dup * ] i put_int nl .
2 [ dup * ] twice put_int nl .
2 [ dup * ] thrice put_int nl .
2 [ square ] 0 times put_int nl .
2 [ square ] 1 times put_int nl .
2 [ square ] 2 times put_int nl .
2 [ square ] 3 times put_int nl .
2 [ square ] 4 times put_int nl .
2 [ square ] 5 times put_int nl .
[ 7 ] 10 times stack put_list_int nl .
[ 1 2 3 ] [ dup * ] map put_list_int nl .
[ 1 2 3 ] 0 [ dup * + ] fold put_int nl .
11 12 [ [ + ] [ * ] [ pop unit ] [ dup pair ] ] construct2 "ii(i)(ii)" put_rec nl .
[ [ pair [ square ] map unpair + ] [ pop ] [ ] ] construct2 put_list_int nl .
[ ] unstack 11111 put_int nl .
64 put_int nl .
64 put_int nl .
255 put_int nl .
65 putch nl .
97 putch nl .
'g putch nl .
[ Smith Jones Robinson ] last putchars nl .
# [ last ] definition putnl .
# [ Smith Jones Robinson ] [ last ] definition i putchars nl .
[ Smith Jones Robinson ]
[ swap dup rest null [ car swap pop ] [ cdr swap x ] branch ] x putchars nl .
[ Smith Jones Robinson ]
[ swap dup rest null [ car swap pop ] [ cdr swap i ] branch ] y putchars nl .
6 factorial_rec put_int nl .
6 [ swap dup 2 < [ pop pop 1 ] [ dup pred rolldown x * ] branch ] x put_int nl .
6 [ swap dup 2 < [ pop pop 1 ] [ dup pred rolldown i * ] branch ] y put_int nl .
[ 1 9 2 8 3 7 4 6 5 ] quicksort put_list_int nl .
[ 5 6 4 7 3 8 2 9 1 ] quicksort put_list_int nl .
[ 1 2 3 4 5 6 7 8 9 ] quicksort put_list_int nl .
[ 9 8 7 6 5 4 3 2 1 ] quicksort put_list_int nl .
# [ quicksort ] definition putnl .
[ [ 1 Smith ] [ 3 Jones ] [ 2 Robinson ] [ 4 Brown ] ] quicksort1
"[ " putchars [ "is" put_rec ] step "]\n" putchars .
[ ] [ NURKS Peter 1989 year 3 major "Computer Science" ] cnos
    [ ABELSON Mary 1990 year 2 major Logic ] cnos
    [ ZEEMAN Fred 1988 year 2 major Accounting ] cnos
    [ MORRIS Janna 1992 year 1 major undecided ] cnos
quicksort2 [ "ssisiss" put_rec nl ] step .
