%INCLUDE stdlib.joy

MODULE rep
PUBLIC
dureco == dup rest cons ;
duco == dup cons ;
fix == [ duco ] swoncat duco ;
deposit == [ dup [ first ] dip ] swoncat ;
durereco == dup rest rest cons ;
fix-a == [ ] [ [ over swons ] unary ] fix-i ;
fix-c == [ 0 [ succ ] infra dureco ] swoncat dureco ;
inter == [ dip cons dureco ] cons [ uncons ] swoncat cons dureco ;
_expand == swap [ dip ] cons concat [ dip ] swoncat cons [ [ dip ] cons
(* [ [ pop ] swoncat ] dip *) ] dip [ ifte ] cons cons cons ;
_binary == [ dip swap i ] _expand ;
count == [ 0 [ succ ] infra ] swoncat ;
exe-t == [ dip dureco ] cons [ [ pred ] infra ] swoncat [ ifte ] cons
[ pop [ [ duco ] duco ] ] swons [ dup first null ] swons cons dureco ;
f-stream-prepare == swap [ dip ] cons concat cons [ dup ] infra dup rest rest
infra uncons uncons [ pop dup ] swoncat [ infra durereco ] cons ;
fix-i == [ dip cons dureco ] cons [ uncons ] swoncat cons swoncat dureco ;
linear == [ i ] _expand ;
n-stream == [ infra dureco ] cons cons dureco ;
n-stream-d == [ infra dureco ] cons deposit cons dureco ;
c-stream == [ dureco ] cons dureco ;
c-stream-d == [ dureco ] deposit cons dureco ;
exe == [ dip duco ] cons duco ;
exe-c == [ dip dureco ] cons count dureco ;
f-stream == f-stream-prepare cons cons durereco ;
f-stream-d == f-stream-prepare deposit cons cons durereco ;
ints == [ dureco ] count dureco ;
self == [ duco ] duco ;
END
DEFINE
trace == "trace: " putchars state put_int nl ;
times10-c == [ 10 * ] rep.exe-c ;
ten-powers-log10 == 1.0 [ 10.0 .* ] [ [ ] cons [ dup log10 ] infra ] rep.f-stream-d ;
swoncat == swap concat ;
steps == "steps: " putchars state put_int nl ;
state == first first ;
squaring == [ dup * ] rep.exe ;
selfr == rep.self ;
qtest == qsort-fix-c i state ;
qtest_str == qsort-fix-c_str i state ;
qsort-fix-c == qsort-bin rep.fix-c ;
qsort-fix-c_str == qsort-bin_str rep.fix-c ;
qsort-bin == [ over small_lst ] [ ] [ uncons [ over over > ] split ] [ enconcat ]
rep._binary ;
qsort-bin_str == [ over small_str ] [ ] [ uncons_str [ over over > ] split_str ]
[ enconcat_str ] rep._binary ;
primes-d == 2 [ succ [ dup prime not ] [ succ ] while ] rep.n-stream-d ;
prime == 2 [ over over dup * > 2 pick 2 pick rem 0 > and ] [ succ ] while dup * < ;
ones-d == 1 rep.c-stream-d ;
ones == 1 rep.c-stream ;
nfib-fix-c == nfib rep.fix-c ;
nfib-fix-a == nfib rep.fix-a ;
nfib-fix == nfib-bin rep.fix ;
nfib-bin == [ over small ] [ pop 1 ] [ pred dup pred ] [ + ] rep._binary ;
nfib == [ [ over small ] [ [ pop 1 ] dip ] [ [ pred dup pred ] dip dip swap i
[ + ] dip ] ifte ] ;
max-4-adds == 4 [ + ] rep.exe-t ;
max-3-adds == 3 [ + ] rep.exe-t ;
length-lin == [ over null ] [ pop 0 ] [ rest ] [ succ ] rep.linear ;
length-fix-a == length-lin rep.fix-a ;
integers-from == [ succ ] rep.n-stream ;
integers == rep.ints ;
halving-d == 1.0 [ 2.0 ./ ] rep.n-stream-d ;
halving == 1.0 [ 2.0 ./ ] rep.n-stream ;
fact0 == [ [ over null ] [ pop pop 1 ] [ [ dup pred ] dip i * ] ifte ] ;
fact-lin == [ over null ] [ pop 1 ] [ dup pred ] [ * ] rep.linear ;
fact-fix-c == fact rep.fix-c ;
fact-fix-a == fact rep.fix-a ;
fact-fix == fact-lin rep.fix ;
fact == [ [ over null ] [ [ pop 1 ] dip ] [ [ dup pred ] dip i [ * ] dip ] ifte ] ;
even-squares == 0 [ 2 + ] [ dup * ] rep.f-stream ;
c == concat ;
accu-sum == 0 [ + ] rep.inter ;
accu-product-list == [ ] [ [ * ] dip cons ] rep.inter ;
accu-list == [ ] [ cons ] rep.inter ;
END 

0 setautoput .
selfr "((y)y)" put_list nl .
selfr i i i "((y)y)" put_list nl .
squaring "(((yy)yy)(yy)yy)" put_list nl .
2 squaring i pop put_int nl .
2 squaring i i pop put_int nl .
2 squaring i i i pop put_int nl .
integers "((i(y)yy)(y)yy)" put_list nl .
integers i i i i i state put_int nl .
integers i i i i i i "((i(y)yy)(y)yy)" put_list nl .
times10-c "((i(y)y(iy)yy)(y)y(iy)yy)" put_list nl .
3 times10-c i i i i i pop put_int nl .
3 times10-c i i i i i popd state put_int nl .
ones "((iy)y)" put_list nl .
ones i i i i i "((iy)y)" put_list nl .
ones i i i i i state put_int nl .
halving "((d(dy)yy)(dy)yy)" put_list nl .
halving i i i "((d(dy)yy)(dy)yy)" put_list nl .
halving i i i state put_dbl nl .
42 integers-from "((i(y)yy)(y)yy)" put_list nl .
42 integers-from i i i i i state put_int nl .
ones-d "((iy(y)yy)y(y)yy)" put_list nl .
ones-d i i i pop put_int nl . put_int nl . put_int nl .
halving-d "((dy(y)y(dy)yy)y(y)y(dy)yy)" put_list nl .
halving-d i i i i i pop put_dbl nl . put_dbl nl . put_dbl nl . put_dbl nl . put_dbl nl .
primes-d "((iy(y)y(y(yyy)(y)y)yy)y(y)y(y(yyy)(y)y)yy)" put_list nl .
primes-d i i i i i pop put_int nl . put_int nl . put_int nl . put_int nl . put_int nl .
even-squares "((ii(yyyy(iy)y)yy)(yyyy(iy)y)yy)" put_list nl .
even-squares state put_int nl .
even-squares i state put_int nl .
even-squares i i state put_int nl .
even-squares i i i state put_int nl .
even-squares i i i i state put_int nl .
ten-powers-log10 "(((dd)dy(y)y(yy()y(yy)y(dy)y)yy)y(y)y(yy()y(yy)y(dy)y)yy)" put_list nl .
ten-powers-log10 i i i i i i pop "(dd)" put_list nl . "(dd)" put_list nl .
"(dd)" put_list nl . "(dd)" put_list nl . "(dd)" put_list nl . "(dd)" put_list nl .
accu-list "((()y(y)yyy)y(y)yyy)" put_list nl .
1 2 3 4 5 accu-list i i i i i state put_list_int nl .
accu-sum "((iy(y)yyy)y(y)yyy)" put_list nl .
1 2 3 4 5 accu-sum i i i i i state put_int nl .
accu-product-list "((()y((y)yy)yyy)y((y)yy)yyy)" put_list nl .
1 10 2 100 3 1000 4 10000 accu-product-list i i i i state put_list_int nl .
max-3-adds "((i(yyy)(y((y)y))((y)y(y)yy)y)(yyy)(y((y)y))((y)y(y)yy)y)" put_list nl .
2 1 max-3-adds i pop put_int nl .
3 2 1 max-3-adds i i pop put_int nl .
4 3 2 1 max-3-adds i i i pop put_int nl .
5 4 3 2 1 max-3-adds i i i i pop put_int nl . put_int nl .
5 4 3 2 1 max-4-adds i i i i pop put_int nl .
6 fact0 rep.fix i put_int nl .
6 fact rep.fix i "((y(yy)((yi)y)((yy)yy(y)y)y)y(yy)((yi)y)((yy)yy(y)y)y)" put_list nl .
put_int nl .
3 fact rep.fix i i "((y(yy)((yi)y)((yy)yy(y)y)y)y(yy)((yi)y)((yy)yy(y)y)y)" put_list nl .
put_int nl .
3 4 5 fact-fix i swap put_int i swap put_int i swap put_int nl pop .
3 4 5 fact-fix-c i swap put_int i swap put_int i swap put_int nl steps .
3 4 5 fact-fix-a i swap put_int i swap put_int i swap put_int nl trace .
nfib-fix "((y(yy)((yi)y)((yyy)yyyy(y)y)y)y(yy)((yi)y)((yyy)yyyy(y)y)y)" put_list nl .
6 nfib-fix i pop put_int nl .
6 nfib-fix-c i swap put_int nl steps .
6 nfib-fix-a i swap put_int nl trace .
4 fact-fix i pop put_int nl .
[ 2 5 3 7 6 ] [ a b c ] length-fix-a i swap put_int i swap put_int nl trace .
6 nfib-fix i pop put_int nl .
6 nfib-bin [ ] [ [ dup put_int ] dip ] rep.fix-i i nl pop put_int . nl .
[ 5 10 9 14 7 18 1 4 15 3 20 19 8 11 2 6 12 13 16 17 ] qtest put_int nl . put_list_int nl .
[ 10 5 3 2 4 1 8 7 9 6 15 13 12 14 11 18 17 19 16 20 ] qtest put_int nl . put_list_int nl .
[ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ] qtest put_int nl . put_list_int nl .
[ 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 ] qtest put_int nl . put_list_int nl .
"You can also sort strings, of course" qtest_str put_int nl . put_str nl .
