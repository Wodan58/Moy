{ "!=", "X Y  ->  B", "Either both X and Y are numeric or both are strings or symbols.\nTests whether X not equal to Y.  Also supports float.\n" },
{ "-", "M I  ->  N", "Numeric N is the result of subtracting integer I from numeric M.\nAlso supports float.\n" },
{ "*", "I J  ->  K", "Integer K is the product of integers I and J.  Also supports float.\n" },
{ "/", "I J  ->  K", "Integer K is the (rounded) ratio of integers I and J.  Also supports float.\n" },
{ "__dump", "->  [..]", "debugging only: pushes the dump as a list.\n" },
{ "__html_manual", "->", "Writes this manual of all Joy primitives to output file in HTML style.\n" },
{ "__latex_manual", "->", "Writes this manual of all Joy primitives to output file in Latex style\nbut without the head and tail.\n" },
{ "__manual_list", "->  L", "Pushes a list L of lists (one per operator) of three documentation strings.\n" },
{ "__memoryindex", "->  I", "Pushes current value of memory.\n" },
{ "__memorymax", "->  I", "Pushes value of total size of memory.\n" },
{ "__settracegc", "I  ->", "Sets value of flag for tracing garbage collection to I (= 0..2).\n" },
{ "__symtabindex", "->  I", "Pushes current size of the symbol table.\n" },
{ "__symtabmax", "->  I", "Pushes value of maximum size of the symbol table.\n" },
{ "_help", "->", "Lists all hidden symbols in library and then all hidden builtin symbols.\n" },
{ "+", "M I  ->  N", "Numeric N is the result of adding integer I to numeric M.\nAlso supports float.\n" },
{ "<", "X Y  ->  B", "Either both X and Y are numeric or both are strings or symbols.\nTests whether X less than Y.  Also supports float.\n" },
{ "<=", "X Y  ->  B", "Either both X and Y are numeric or both are strings or symbols.\nTests whether X less than or equal to Y.  Also supports float.\n" },
{ "=", "X Y  ->  B", "Either both X and Y are numeric or both are strings or symbols.\nTests whether X equal to Y.  Also supports float.\n" },
{ ">", "X Y  ->  B", "Either both X and Y are numeric or both are strings or symbols.\nTests whether X greater than Y.  Also supports float.\n" },
{ ">=", "X Y  ->  B", "Either both X and Y are numeric or both are strings or symbols.\nTests whether X greater than or equal to Y.  Also supports float.\n" },
{ "abort", "->", "Aborts execution of current Joy program, returns to Joy main cycle.\n" },
{ "abs", "N1  ->  N2", "Integer N2 is the absolute value (0,1,2..) of integer N1,\nor float N2 is the absolute value (0.0 ..) of float N1.\n" },
{ "acos", "F  ->  G", "G is the arc cosine of F.\n" },
{ "all", "A [B]  ->  X", "Applies test B to members of aggregate A, X = true if all pass.\n" },
{ "and", "X Y  ->  Z", "Z is the intersection of sets X and Y, logical conjunction for truth values.\n" },
{ "app1", "X [P]  ->  R", "Executes P, pushes result R on stack with X.\n" },
{ "app11", "X Y [P]  ->  R", "Executes P, pushes result R on stack.\n" },
{ "app12", "X Y1 Y2 [P]  ->  R1 R2", "Executes P twice, with Y1 and Y2, returns R1 and R2.\n" },
{ "app2", "X1 X2 [P]  ->  R1 R2", "Obsolescent.  ==  unary2\n" },
{ "app3", "X1 X2 X3 [P]  ->  R1 R2 R3", "Obsolescent.  == unary3\n" },
{ "app4", "X1 X2 X3 X4 [P]  ->  R1 R2 R3 R4", "Obsolescent.  == unary4\n" },
{ "argc", "->  I", "Pushes the number of command line arguments. This is quivalent to 'argv size'.\n" },
{ "argv", "->  A", "Creates an aggregate A containing the interpreter's command line arguments.\n" },
{ "asin", "F  ->  G", "G is the arc sine of F.\n" },
{ "at", "A I  ->  X", "X (= A[I]) is the member of A at position I.\n" },
{ "atan", "F  ->  G", "G is the arc tangent of F.\n" },
{ "atan2", "F G  ->  H", "H is the arc tangent of F / G.\n" },
{ "autoput", "->  I", "Pushes current value of flag for automatic output, I = 0..2.\n" },
{ "binary", "X Y [P]  ->  R", "Executes P, which leaves R on top of the stack.\nNo matter how many parameters this consumes,\nexactly two are removed from the stack.\n" },
{ "binrec", "[P] [T] [R1] [R2]  ->  ...", "Executes P. If that yields true, executes T.\nElse uses R1 to produce two intermediates, recurses on both,\nthen executes R2 to combine their results.\n" },
{ "body", "U  ->  [P]", "Quotation [P] is the body of user-defined symbol U.\n" },
{ "branch", "B [T] [F]  ->  ...", "If B is true, then executes T else executes F.\n" },
{ "case", "X [..[X Y]..]  ->  Y i", "Indexing on the value of X, execute the matching Y.\n" },
{ "casting", "X Y  ->  Z", "Z takes the value from X and the type from Y.\n" },
{ "ceil", "F  ->  G", "G is the float ceiling of F.\n" },
{ "char", "X  ->  B", "Tests whether X is a character.\n" },
{ "choice", "B T F  ->  X", "If B is true, then X = T else X = F.\n" },
{ "chr", "I  ->  C", "C is the character whose Ascii value is integer I (or logical or character).\n" },
{ "cleave", "X [P1] [P2]  ->  R1 R2", "Executes P1 and P2, each with X on top, producing two results.\n" },
{ "clock", "->  I", "Pushes the integer value of current CPU usage in milliseconds.\n" },
{ "compare", "A B  ->  I", "I (=-1,0,+1) is the comparison of aggregates A and B.\nThe values correspond to the predicates <=, =, >=.\n" },
{ "concat", "S T  ->  U", "Sequence U is the concatenation of sequences S and T.\n" },
{ "cond", "[..[[Bi] Ti]..[D]]  ->  ...", "Tries each Bi. If that yields true, then executes Ti and exits.\nIf no Bi yields true, executes default D.\n" },
{ "condlinrec", "[ [C1] [C2] .. [D] ]  ->  ...", "Each [Ci] is of the form [[B] [T]] or [[B] [R1] [R2]].\nTries each B. If that yields true and there is just a [T], executes T and exit.\nIf there are [R1] and [R2], executes R1, recurses, executes R2.\nSubsequent case are ignored. If no B yields true, then [D] is used.\nIt is then of the form [[T]] or [[R1] [R2]]. For the former, executes T.\nFor the latter executes R1, recurses, executes R2.\n" },
{ "condnestrec", "[ [C1] [C2] .. [D] ]  ->  ...", "A generalisation of condlinrec.\nEach [Ci] is of the form [[B] [R1] [R2] .. [Rn]] and [D] is of the form\n[[R1] [R2] .. [Rn]]. Tries each B, or if all fail, takes the default [D].\nFor the case taken, executes each [Ri] but recurses between any two\nconsecutive [Ri] (n > 3 would be exceptional.)\n" },
{ "cons", "X A  ->  B", "Aggregate B is A with a new member X (first member for sequences).\n" },
{ "construct", "[P] [[P1] [P2] ..]  ->  R1 R2 ..", "Saves state of stack and then executes [P].\nThen executes each [Pi] to give Ri pushed onto saved stack.\n" },
{ "conts", "->  [[P] [Q] ..]", "Pushes current continuations. Buggy, do not use.\n" },
{ "cos", "F  ->  G", "G is the cosine of F.\n" },
{ "cosh", "F  ->  G", "G is the hyperbolic cosine of F.\n" },
{ "dip", "X [P]  ->  ...  X", "Saves X, executes P, pushes X back.\n" },
{ "div", "I J  ->  K L", "Integers K and L are the quotient and remainder of dividing I by J.\n" },
{ "drop", "A N  ->  B", "Aggregate B is the result of deleting the first N elements of A.\n" },
{ "dup", "X  ->  X X", "Pushes an extra copy of X onto stack.\n" },
{ "dupd", "Y Z  ->  Y Y Z", "As if defined by:   dupd  ==  [dup] dip\n" },
{ "echo", "->  I", "Pushes value of echo flag, I = 0..3.\n" },
{ "enconcat", "X S T  ->  U", "Sequence U is the concatenation of sequences S and T\nwith X inserted between S and T (== swapd cons concat).\n" },
{ "equal", "T U  ->  B", "(Recursively) tests whether trees T and U are identical.\n" },
{ "exp", "F  ->  G", "G is e (2.718281828...) raised to the Fth power.\n" },
{ "fclose", "S  ->", "Stream S is closed and removed from the stack.\n" },
{ "feof", "S  ->  S B", "B is the end-of-file status of stream S.\n" },
{ "ferror", "S  ->  S B", "B is the error status of stream S.\n" },
{ "fflush", "S  ->  S", "Flush stream S, forcing all buffered output to be written.\n" },
{ "fget", "S  ->  S F", "Reads a factor from stream S and pushes it onto stack.\n" },
{ "fgetch", "S  ->  S C", "C is the next available character from stream S.\n" },
{ "fgets", "S  ->  S L", "L is the next available line (as a string) from stream S.\n" },
{ "file", "F  ->  B", "Tests whether F is a file.\n" },
{ "filetime", "F  ->  T", "T is the modification time of file F.\n" },
{ "filter", "A [B]  ->  A1", "Uses test B to filter aggregate A producing sametype aggregate A1.\n" },
{ "first", "A  ->  F", "F is the first member of the non-empty aggregate A.\n" },
{ "float", "R  ->  B", "Tests whether R is a float.\n" },
{ "floor", "F  ->  G", "G is the floor of F.\n" },
{ "fold", "A V0 [P]  ->  V", "Starting with value V0, sequentially pushes members of aggregate A\nand combines with binary operator P to produce value V.\n" },
{ "fopen", "P M  ->  S", "The file system object with pathname P is opened with mode M (r, w, a, etc.)\nand stream object S is pushed; if the open fails, file:NULL is pushed.\n" },
{ "format", "N C I J  ->  S", "S is the formatted version of N in mode C\n('d or 'i = decimal, 'o = octal, 'x or\n'X = hex with lower or upper case letters)\nwith maximum width I and minimum width J.\n" },
{ "formatf", "F C I J  ->  S", "S is the formatted version of F in mode C\n('e or 'E = exponential, 'f = fractional,\n'g or G = general with lower or upper case letters)\nwith maximum width I and precision J.\n" },
{ "fput", "S X  ->  S", "Writes X to stream S, pops X off stack.\n" },
{ "fputch", "S C  ->  S", "The character C is written to the current position of stream S.\n" },
{ "fputchars", "S \"abc..\"  ->  S", "The string abc.. (no quotes) is written to the current position of stream S.\n" },
{ "fputstring", "S \"abc..\"  ->  S", "== fputchars, as a temporary alternative.\n" },
{ "fread", "S I  ->  S L", "I bytes are read from the current position of stream S\nand returned as a list of I integers.\n" },
{ "fremove", "P  ->  B", "The file system object with pathname P is removed from the file system.\nB is a boolean indicating success or failure.\n" },
{ "frename", "P1 P2  ->  B", "The file system object with pathname P1 is renamed to P2.\nB is a boolean indicating success or failure.\n" },
{ "frexp", "F  ->  G I", "G is the mantissa and I is the exponent of F.\nUnless F = 0, 0.5 <= abs(G) < 1.0.\n" },
{ "fseek", "S P W  ->  S B", "Stream S is repositioned to position P relative to whence-point W,\nwhere W = 0, 1, 2 for beginning, current position, end respectively.\n" },
{ "ftell", "S  ->  S I", "I is the current position of stream S.\n" },
{ "fwrite", "S L  ->  S", "A list of integers are written as bytes to the current position of stream S.\n" },
{ "gc", "->", "Initiates garbage collection.\n" },
{ "genrec", "[B] [T] [R1] [R2]  ->  ...", "Executes B, if that yields true, executes T.\nElse executes R1 and then [[[B] [T] [R1] R2] genrec] R2.\n" },
{ "get", "->  F", "Reads a factor from input and pushes it onto stack.\n" },
{ "getch", "->  N", "Reads a character from input and puts it onto stack.\n" },
{ "getenv", "\"variable\"  ->  \"value\"", "Retrieves the value of the environment variable \"variable\".\n" },
{ "gmtime", "I  ->  T", "Converts a time I into a list T representing universal time:\n[year month day hour minute second isdst yearday weekday].\nMonth is 1 = January ... 12 = December;\nisdst is false; weekday is 1 = Monday ... 7 = Sunday.\n" },
{ "has", "A X  ->  B", "Tests whether aggregate A has X as a member.\n" },
{ "help", "->", "Lists all defined symbols, including those from library files.\nThen lists all primitives of raw Joy.\n(There is a variant: \"_help\" which lists hidden symbols).\n" },
{ "helpdetail", "[ S1 S2 .. ]  ->", "Gives brief help on each symbol S in the list.\n" },
{ "i", "[P]  ->  ...", "Executes P. So, [P] i  ==  P.\n" },
{ "id", "->", "Identity function, does nothing.\nAny program of the form  P id Q  is equivalent to just  P Q.\n" },
{ "ifchar", "X [T] [E]  ->  ...", "If X is a character, executes T else executes E.\n" },
{ "iffile", "X [T] [E]  ->  ...", "If X is a file, executes T else executes E.\n" },
{ "iffloat", "X [T] [E]  ->  ...", "If X is a float, executes T else executes E.\n" },
{ "ifinteger", "X [T] [E]  ->  ...", "If X is an integer, executes T else executes E.\n" },
{ "iflist", "X [T] [E]  ->  ...", "If X is a list, executes T else executes E.\n" },
{ "iflogical", "X [T] [E]  ->  ...", "If X is a logical or truth value, executes T else executes E.\n" },
{ "ifset", "X [T] [E]  ->  ...", "If X is a set, executes T else executes E.\n" },
{ "ifstring", "X [T] [E]  ->  ...", "If X is a string, executes T else executes E.\n" },
{ "ifte", "[B] [T] [F]  ->  ...", "Executes B. If that yields true, then executes T else executes F.\n" },
{ "in", "X A  ->  B", "Tests whether X is a member of aggregate A.\n" },
{ "in1", "X A  ->  B", "Tests whether X is a member of aggregate A.\n" },
{ "include", "\"filnam.ext\"  ->", "Transfers input to file whose name is \"filnam.ext\".\nOn end-of-file returns to previous input file.\n" },
{ "index", "I A  ->  X", "X (= A[I]) is the member of A at position I (I = 0,1).\n" },
{ "infra", "L1 [P]  ->  L2", "Using list L1 as stack, executes P and returns a new list L2.\nThe first element of L1 is used as the top of stack,\nand after execution of P the top of stack becomes the first element of L2.\n" },
{ "integer", "X  ->  B", "Tests whether X is an integer.\n" },
{ "intern", "\"sym\"  ->  sym", "Pushes the item whose name is \"sym\".\n" },
{ "ldexp", "F I  ->  G", "G is F times 2 to the Ith power.\n" },
{ "leaf", "X  ->  B", "Tests whether X is not a list.\n" },
{ "linrec", "[P] [T] [R1] [R2]  ->  ...", "Executes P. If that yields true, executes T.\nElse executes R1, recurses, executes R2.\n" },
{ "list", "X  ->  B", "Tests whether X is a list.\n" },
{ "localtime", "I  ->  T", "Converts a time I into a list T representing local time:\n[year month day hour minute second isdst yearday weekday].\nMonth is 1 = January ... 12 = December;\nisdst is a Boolean flagging daylight savings/summer time;\nweekday is 1 = Monday ... 7 = Sunday.\n" },
{ "log", "F  ->  G", "G is the natural logarithm of F.\n" },
{ "log10", "F  ->  G", "G is the common logarithm of F.\n" },
{ "logical", "X  ->  B", "Tests whether X is a logical.\n" },
{ "manual", "->", "Writes this manual of all Joy primitives to output file.\n" },
{ "map", "A [P]  ->  B", "Executes P on each member of aggregate A,\ncollects results in sametype aggregate B.\n" },
{ "max", "N1 N2  ->  N", "N is the maximum of numeric values N1 and N2.  Also supports float.\n" },
{ "min", "N1 N2  ->  N", "N is the minimum of numeric values N1 and N2.  Also supports float.\n" },
{ "mktime", "T  ->  I", "Converts a list T representing local time into a time I.\nT is in the format generated by localtime.\n" },
{ "modf", "F  ->  G H", "G is the fractional part and H is the integer part\n(but expressed as a float) of F.\n" },
{ "name", "sym  ->  \"sym\"", "For operators and combinators, the string \"sym\" is the name of item sym,\nfor literals sym the result string is its type.\n" },
{ "neg", "I  ->  J", "Integer J is the negative of integer I.  Also supports float.\n" },
{ "not", "X  ->  Y", "Y is the complement of set X, logical negation for truth values.\n" },
{ "nothing", "->  nothing", "Pushes the value nothing.\n" },
{ "null", "X  ->  B", "Tests for empty aggregate X or zero numeric.\n" },
{ "nullary", "[P]  ->  R", "Executes P, which leaves R on top of the stack.\nNo matter how many parameters this consumes, none are removed from the stack.\n" },
{ "of", "I A  ->  X", "X (= A[I]) is the I-th member of aggregate A.\n" },
{ "opcase", "X [..[X Xs]..]  ->  X [Xs]", "Indexing on type of X, returns the list [Xs].\n" },
{ "or", "X Y  ->  Z", "Z is the union of sets X and Y, logical disjunction for truth values.\n" },
{ "ord", "C  ->  I", "Integer I is the Ascii value of character C (or logical or integer).\n" },
{ "over", "X Y  ->  X Y X", "Pushes an extra copy of the second item X on top of the stack.\n" },
{ "pick", "X Y Z 2  ->  X Y Z X", "Pushes an extra copy of nth (e.g. 2) item X on top of the stack.\n" },
{ "pop", "X  ->", "Removes X from top of the stack.\n" },
{ "popd", "Y Z  ->  Z", "As if defined by:   popd  ==  [pop] dip\n" },
{ "pow", "F G  ->  H", "H is F raised to the Gth power.\n" },
{ "pred", "M  ->  N", "Numeric N is the predecessor of numeric M.\n" },
{ "primrec", "X [I] [C]  ->  R", "Executes I to obtain an initial value R0.\nFor integer X uses increasing positive integers to X, combines by C for new R.\nFor aggregate X uses successive members and combines by C for new R.\n" },
{ "put", "X  ->", "Writes X to output, pops X off stack.\n" },
{ "putch", "N  ->", "N : numeric, writes character whose ASCII is N.\n" },
{ "putchars", "\"abc..\"  ->", "Writes abc.. (without quotes)\n" },
{ "quit", "->", "Exit from Joy.\n" },
{ "rand", "->  I", "I is a random integer.\n" },
{ "rem", "I J  ->  K", "Integer K is the remainder of dividing I by J.  Also supports float.\n" },
{ "rest", "A  ->  R", "R is the non-empty aggregate A with its first member removed.\n" },
{ "rolldown", "X Y Z  ->  Y Z X", "Moves Y and Z down, moves X up.\n" },
{ "rolldownd", "X Y Z W  ->  Y Z X W", "As if defined by:   rolldownd  ==  [rolldown] dip\n" },
{ "rollup", "X Y Z  ->  Z X Y", "Moves X and Y up, moves Z down.\n" },
{ "rollupd", "X Y Z W  ->  Z X Y W", "As if defined by:   rollupd  ==  [rollup] dip\n" },
{ "rotate", "X Y Z  ->  Z Y X", "Interchanges X and Z.\n" },
{ "rotated", "X Y Z W  ->  Z Y X W", "As if defined by:   rotated  ==  [rotate] dip\n" },
{ "round", "F  ->  G", "G is F rounded to the nearest integer.\n" },
{ "sametype", "X Y  ->  B", "Tests whether X and Y have the same type.\n" },
{ "set", "X  ->  B", "Tests whether X is a set.\n" },
{ "setautoput", "I  ->", "Sets value of flag for automatic put to I (if I = 0, none;\nif I = 1, put; if I = 2, stack).\n" },
{ "setecho", "I  ->", "Sets value of echo flag for listing.\nI = 0: no echo, 1: echo, 2: with tab, 3: and linenumber.\n" },
{ "setsize", "->  setsize", "Pushes the maximum number of elements in a set (platform dependent).\nTypically it is 32, and set members are in the range 0..31.\n" },
{ "setundeferror", "I  ->", "Sets flag that controls behavior of undefined functions\n(0 = no error, 1 = error).\n" },
{ "sign", "N1  ->  N2", "Integer N2 is the sign (-1 or 0 or +1) of integer N1,\nor float N2 is the sign (-1.0 or 0.0 or 1.0) of float N1.\n" },
{ "sin", "F  ->  G", "G is the sine of F.\n" },
{ "sinh", "F  ->  G", "G is the hyperbolic sine of F.\n" },
{ "size", "A  ->  I", "Integer I is the number of elements of aggregate A.\n" },
{ "small", "X  ->  B", "Tests whether aggregate X has 0 or 1 members, or numeric 0 or 1.\n" },
{ "some", "A [B]  ->  X", "Applies test B to members of aggregate A, X = true if some pass.\n" },
{ "split", "A [B]  ->  A1 A2", "Uses test B to split aggregate A into sametype aggregates A1 and A2.\n" },
{ "sqrt", "F  ->  G", "G is the square root of F.\n" },
{ "srand", "I  ->", "Sets the random integer seed to integer I.\n" },
{ "stack", ".. X Y Z  ->  .. X Y Z [Z Y X ..]", "Pushes the stack as a list.\n" },
{ "stderr", "->  S", "Pushes the standard error stream.\n" },
{ "stdin", "->  S", "Pushes the standard input stream.\n" },
{ "stdout", "->  S", "Pushes the standard output stream.\n" },
{ "step", "A [P]  ->  ...", "Sequentially putting members of aggregate A onto stack,\nexecutes P for each member of A.\n" },
{ "strftime", "T S1  ->  S2", "Formats a list T in the format of localtime or gmtime\nusing string S1 and pushes the result S2.\n" },
{ "string", "X  ->  B", "Tests whether X is a string.\n" },
{ "strtod", "S  ->  R", "String S is converted to the float R.\n" },
{ "strtol", "S I  ->  J", "String S is converted to the integer J using base I.\nIf I = 0, assumes base 10,\nbut leading \"0\" means base 8 and leading \"0x\" means base 16.\n" },
{ "succ", "M  ->  N", "Numeric N is the successor of numeric M.\n" },
{ "swap", "X Y  ->  Y X", "Interchanges X and Y on top of the stack.\n" },
{ "swapd", "X Y Z  ->  Y X Z", "As if defined by:   swapd  ==  [swap] dip\n" },
{ "swons", "A X  ->  B", "Aggregate B is A with a new member X (first member for sequences).\n" },
{ "system", "\"command\"  ->", "Escapes to shell, executes string \"command\".\nThe string may cause execution of another program.\nWhen that has finished, the process returns to Joy.\n" },
{ "tailrec", "[P] [T] [R1]  ->  ...", "Executes P. If that yields true, executes T.\nElse executes R1, recurses.\n" },
{ "take", "A N  ->  B", "Aggregate B is the result of retaining just the first N elements of A.\n" },
{ "tan", "F  ->  G", "G is the tangent of F.\n" },
{ "tanh", "F  ->  G", "G is the hyperbolic tangent of F.\n" },
{ "ternary", "X Y Z [P]  ->  R", "Executes P, which leaves R on top of the stack.\nNo matter how many parameters this consumes,\nexactly three are removed from the stack.\n" },
{ "time", "->  I", "Pushes the current time (in seconds since the Epoch).\n" },
{ "times", "N [P]  ->  ...", "N times executes P.\n" },
{ "treegenrec", "T [O1] [O2] [C]  ->  ...", "T is a tree. If T is a leaf, executes O1.\nElse executes O2 and then [[[O1] [O2] C] treegenrec] C.\n" },
{ "treerec", "T [O] [C]  ->  ...", "T is a tree. If T is a leaf, executes O. Else executes [[[O] C] treerec] C.\n" },
{ "treestep", "T [P]  ->  ...", "Recursively traverses leaves of tree T, executes P for each leaf.\n" },
{ "trunc", "F  ->  I", "I is an integer equal to the float F truncated toward zero.\n" },
{ "unary", "X [P]  ->  R", "Executes P, which leaves R on top of the stack.\nNo matter how many parameters this consumes,\nexactly one is removed from the stack.\n" },
{ "unary2", "X1 X2 [P]  ->  R1 R2", "Executes P twice, with X1 and X2 on top of the stack.\nReturns the two values R1 and R2.\n" },
{ "unary3", "X1 X2 X3 [P]  ->  R1 R2 R3", "Executes P three times, with Xi, returns Ri (i = 1..3).\n" },
{ "unary4", "X1 X2 X3 X4 [P]  ->  R1 R2 R3 R4", "Executes P four times, with Xi, returns Ri (i = 1..4).\n" },
{ "uncons", "A  ->  F R", "F and R are the first and the rest of non-empty aggregate A.\n" },
{ "undeferror", "->  I", "Pushes current value of undefined-is-error flag.\n" },
{ "undefs", "->  [..]", "Push a list of all undefined symbols in the current symbol table.\n" },
{ "unstack", "[X Y ..]  ->  ..Y X", "The list [X Y ..] becomes the new stack.\n" },
{ "unswons", "A  ->  R F", "R and F are the rest and the first of non-empty aggregate A.\n" },
{ "user", "X  ->  B", "Tests whether X is a user-defined symbol.\n" },
{ "while", "[B] [D]  ->  ...", "While executing B yields true executes D.\n" },
{ "x", "[P] x  ->  ...", "Executes P without popping [P]. So, [P] x  ==  [P] P.\n" },
{ "xor", "X Y  ->  Z", "Z is the symmetric difference of sets X and Y,\nlogical exclusive disjunction for truth values.\n" },
